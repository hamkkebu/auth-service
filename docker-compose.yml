services:
  database:
    image: mysql:8.0
    platform: linux/amd64
    container_name: hamkkebu-auth-service-db
    ports:
      # Auth Service는 MySQL 3307 포트 사용 (Boilerplate는 3306)
      # SECURITY: 포트를 127.0.0.1로 바인딩 (외부 접근 차단)
      - "127.0.0.1:${DB_PORT:-3307}:3306"
    environment:
      - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD:-root}
      - MYSQL_DATABASE=${DB_NAME:-hamkkebu_auth}
    command:
      - --innodb-use-native-aio=0
      - --innodb-flush-method=fsync
      - --default-authentication-plugin=mysql_native_password
    volumes:
      - mysql-data:/var/lib/mysql
      - ./backend/src/main/resources/schema.sql:/docker-entrypoint-initdb.d/1-schema.sql
      - ./backend/src/main/resources/data.sql:/docker-entrypoint-initdb.d/2-data.sql
    networks:
      - auth-internal
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-u", "root", "-p${MYSQL_ROOT_PASSWORD:-root}"]
      interval: 10s
      timeout: 5s
      retries: 5

  backend:
    build:
      context: .
      dockerfile: backend/Dockerfile
    container_name: hamkkebu-auth-service-backend
    ports:
      # auth-service는 8081 포트 사용 (boilerplate는 8080)
      - "${BACKEND_PORT:-8081}:8081"
      # gRPC 포트 (auth-service는 9091, boilerplate는 9090)
      - "${GRPC_PORT:-9091}:9091"
    extra_hosts:
      - "host.docker.internal:host-gateway"
    environment:
      # 개발 프로필 활성화 (포트 설정 적용)
      SPRING_PROFILES_ACTIVE: ${SPRING_PROFILES_ACTIVE:-dev}
      # 내부 네트워크의 DB에 연결
      SPRING_DATASOURCE_URL: jdbc:mysql://database:3306/${DB_NAME:-hamkkebu_auth}?createDatabaseIfNotExist=true&useUnicode=true&characterEncoding=utf8
      SPRING_DATASOURCE_USERNAME: root
      SPRING_DATASOURCE_PASSWORD: ${MYSQL_ROOT_PASSWORD:-root}
      JWT_SECRET: ${JWT_SECRET}
      # 공유 인프라 네트워크의 Redis/Kafka에 연결 (컨테이너 이름 사용)
      REDIS_HOST: hamkkebu-boilerplate-redis
      REDIS_PORT: 6379
      REDIS_PASSWORD: ${REDIS_PASSWORD:-devRedisPassword123!}
      KAFKA_BOOTSTRAP_SERVERS: hamkkebu-boilerplate-kafka:29092
      LOGIN_MAX_ATTEMPTS: ${LOGIN_MAX_ATTEMPTS:-20}
      LOGIN_BLOCK_DURATION: ${LOGIN_BLOCK_DURATION:-3}
      # Keycloak SSO 설정 (Docker 컨테이너에서 호스트 머신 접근)
      SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWT_ISSUER_URI: http://host.docker.internal:8180/realms/hamkkebu
      SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWT_JWK_SET_URI: http://host.docker.internal:8180/realms/hamkkebu/protocol/openid-connect/certs
      KEYCLOAK_AUTH_SERVER_URL: http://host.docker.internal:8180
      KEYCLOAK_REALM: ${KEYCLOAK_REALM:-hamkkebu}
      # Keycloak Admin API (사용자 삭제용)
      KEYCLOAK_ADMIN_REALM: ${KEYCLOAK_ADMIN_REALM:-master}
      KEYCLOAK_ADMIN_CLIENT_ID: ${KEYCLOAK_ADMIN_CLIENT_ID:-admin-cli}
      KEYCLOAK_ADMIN_USERNAME: ${KEYCLOAK_ADMIN_USERNAME:-admin}
      KEYCLOAK_ADMIN_PASSWORD: ${KEYCLOAK_ADMIN_PASSWORD:-admin}
    restart: always
    depends_on:
      database:
        condition: service_healthy
    networks:
      - auth-internal
      - hamkkebu-infra

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: hamkkebu-auth-service-frontend
    ports:
      # Auth Service Frontend는 3001 포트 사용 (Boilerplate는 3000)
      - "${FRONTEND_PORT:-3001}:80"
    restart: always
    depends_on:
      - backend
    networks:
      - auth-internal

networks:
  # 내부 전용 네트워크 (DB 격리)
  auth-internal:
    driver: bridge

  # 공유 인프라 네트워크 (외부에서 생성됨)
  hamkkebu-infra:
    external: true

volumes:
  mysql-data:
